/* IPOPT/include/Ipopt_Interface.h.  Generated by configure.  */
/*
Copyright (C) 2002, Kirk Abbott, International Business Machines, and others.
All Rights Reserved.
This code is published under the Common Public License.
*/

/* $Id: Ipopt_Interface.h 621 2004-06-05 01:41:52Z andreasw $ */

#ifndef IPOPT_INTERFACE_H
#define IPOPT_INTERFACE_H

#ifdef __cplusplus
extern "C" {
#endif

/* Define the Fortran data types */
#ifndef INTEGER_TYPE
#define INTEGER_TYPE long
#endif
typedef INTEGER_TYPE fint;
typedef double real;

/* Macros for Fortran function names */
#ifndef F77_FUNC
#define F77_FUNC(name,NAME) NAME
#endif
#ifndef F77_FUNC_
#define F77_FUNC_(name,NAME) NAME
#endif

#ifdef BUILD_VSDLL
# define DLLEXPORT __declspec(dllexport)
#else
# define DLLEXPORT
#endif

/*
****************************************************************************
* Function and gradient evaluation routines which must be supplied
* by a client.
* (see READEME.IPOPT for a detailed description)
****************************************************************************
*/

/*
Eval_F: Compute the value of the objective function

   n:   number of optimization variables
   x:   values of optimization variables at which objective function
        is to be evaluated
   f:   value of the objective function
   userData: user supplied pointer given to Ipopt_Solve
*/
typedef int(*pEval_F)(fint n, real *x, real *f, void *userData);

/*
Eval_C: Compute the values of the constraints

   n:   number of optimization variables
   x:   values of optimization variables at which constraints
        are to be evaluated
   m:   number of constraints
   c:   values of the constraints
   userData: user supplied pointer given to Ipopt_Solve
*/
typedef int(*pEval_C)(fint n, real *x, fint m, real *c,
                      void *userData);

/*
Eval_G: Compute the gradient of the objective function

   n:   number of optimization variables
   x:   values of optimization variables at which gradient
        is to be evaluated
   g:   values of the gradient
   userData: user supplied pointer given to Ipopt_Solve
*/
typedef int(*pEval_G)(fint n, real *x, real *g, void *userData);

/*
Eval_A: Compute the Jacobian of the constraints

   task: if 0, the only return number of nonzeros in nz
         otherwise:

   n:    number of optimization variables
   x:    values of optimization variables at which constraint Jacobian
         is to be evaluated
   nz:   number of nonzeros in Jacobian
   A:    values of the Jacobian entries
   Acon: row indices of the Jacobian entries
   Avar: column indices of the Jacobian entries
   userData: user supplied pointer given to Ipopt_Solve
*/
typedef int(*pEval_A)(fint task, fint n, real *x, fint *nzA,
                      real *A, fint *Acon, fint *Avar, void *userData);

/*
Eval_H: Compute the Hessian of the Lagrangian function

   task:   if 0, the only return number of nonzeros in nnzh
           otherwise:

   n:      number of optimization variables
   x:      values of optimization variables at which constraint Jacobian
           is to be evaluated
   m:      number of constraints
   lambda: values of multipliers
   nnzh:   number of nonzeros in Jacobian
   hess:   values of the Hessian entries
   irnh:   row indices of the Hessian entries
   icnh:   column indices of the Hessian entries
   userData: user supplied pointer given to Ipopt_Solve
*/
typedef int(*pEval_H)(fint task, fint n, real *x, fint m,
                      real *lambda, fint *nnzh, real *hess,
                      fint *irnh, fint *icnh, void *userData);

typedef struct _Ipopt *Ipopt;

/*
 ****************************************************************************
 * Interface routines for IPOPT
 ****************************************************************************
*/

/* Ipopt_Create: Create Ipopt object for problem with given size:
   n:      number of optimization variables
   m:      number of constraints


   nlb:    number of lower bounds on variables
   ilb:    indices for lower bounds (array length nlb)
   bnds_l: values of lower bounds (array length nlb)
              i.e. variable x[ilb[i]] has lower bound bnds_l[i] for i=1,..,nlb
   nub:    number of upper bounds on variables
   iub:    indices for upper bounds (array length nub)
   bnds_u: values of upper bounds (array length nub)
              i.e. variable x[iub[i]] has upper bound bnds_u[i] for i=1,..,nub

   Eval_F: Pointer to function for evaluating objective function
   Eval_C: Pointer to function for evaluating constraint functions
   Eval_G: Pointer to function for evaluating objective gradient
   Eval_A: Pointer to function for evaluating constraint Jacobian
   Eval_H: Pointer to function for evaluating Lagrangian Hessian

   (All arrays are copied, i.e. you can free them after call of Ipopt_Create)
*/
extern Ipopt DLLEXPORT Ipopt_Create(fint n, fint m, fint nlb,
				    fint *ilb, real *bnds_l, fint nub,
				    fint *iub, real *bnds_u, pEval_F Eval_F,
				    pEval_C Eval_C, pEval_G Eval_G,
				    pEval_A Eval_A, pEval_H Eval_H);

/* Ipopt_Destroy: Free memory allocated for an Ipopt object */
extern void DLLEXPORT Ipopt_Destroy(Ipopt problem);

/* Ipopt_AddParam: Set value of an algorithmic parameter for IPOPT

   name:  key string identifying parameter (see README.IPOPT)
   value: values for that parameter
*/
extern int DLLEXPORT Ipopt_AddParam(Ipopt problem, char *name, real value);

/* Ipopt_Solve: Call the optimizer and solve the problem

   userData: this pointer will be available in all evaluation functions below.
             It will never be touched by IPOPT
             (can be used to store common data etc)
   x:        on input: initial values for the varialbes (array length n)
               output: final iterate (optimal solution)
   Obj:      final value of objective function (output)
   v_lb:     final multipliers for lower bounds (output) (array length nlb)
   v_ub:     final multipliers for upper bounds (output) (array length nub)
   lambda:   final multipliers for equality constraints (output)
               (array length m)
   c:        final values of the constraints (output) (array length m)
   iter:     number of iterations taken (output)

   return code is the output IERR of the IPOPT call (see README.IPOPT)
*/
extern int DLLEXPORT Ipopt_Solve(Ipopt problem, void *userData, real *x,
				 real *Obj, real *v_lb, real *v_ub,
				 real *lambda, real *c, fint *iter);
/*
*****************************************************************************
* Version information.
*****************************************************************************
*/
extern char DLLEXPORT *Ipopt_Version();

/* Call the folling function with argunebt zero if you want to
   suppress any output from the IPOPT C interface
  (such as error or warning messages)
*/
extern void DLLEXPORT Ipopt_SetVerbose(int verbose);

#ifdef __cplusplus
}
#endif

#endif /* IPOPT_INTERFACE_H */
